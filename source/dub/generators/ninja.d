/**
 * Generator for Ninja build
 *
 * Copyright: © 2021 The D Language Foundation
 * License: Subject to the terms of the MIT license, as written in the included LICENSE.txt file.
 * Authors: Luís Ferreira
*/

module dub.generators.ninja;

import dub.project;
import dub.generators.generator;
import dub.compilers.buildsettings;
import dub.platform;
import dub.internal.vibecompat.inet.path;

import std.format: formattedWrite, format;
import std.stdio: File, write;
import std.range : chain;
import std.path : buildPath;
import std.file : getcwd, thisExePath;
import std.ascii : isWhite;
import std.typecons : Tuple, tuple;
import core.runtime : Runtime;

import std.path;
import std.algorithm;
import std.process;
import std.array;

class NinjaGenerator : ProjectGenerator
{
	/// Simple header to write at the beggining of the file
	private enum HEADER_CONTENT = `# Generated by dub build system

# This file contains all the build targets required by dub. Editing this file
# may break it's flow and possibly won't build properly. Don't edit or do it at
# your own risk!

# =============================================================================
# Project:       %1$s
# Build Type:    %2$s
# Compiler:      %3$s
# Configuration: %4$s
# =============================================================================

`;

	/**
	 * Represents a ninja file builder with methods to help
	 * constructing a working ninja file
	 */
	struct NinjaFileBuilder
	{

		/**
		 * Add a build target to the ninja file
		 *
		 * Params:
		 *   rule = ninja rule
		 *   output = output file
		 *   inputs = input file path
		 *   variables = key-value based variables to override
		 */
		void addBuildTarget(
			in string rule,
			in string output,
			in string[] inputs = [],
			in string[string] variables = string[string].init
		)
			in(!rule.any!isWhite &&
				inputs.all!"a.length > 0")
		{
			targets ~= format!"build %s: %s %-(%s%| $\n    %)\n%s"(
				output, rule, inputs, generateVariablesList(variables)
			);
		}

		/**
		 * Add a phony target to the ninja file
		 *
		 * Params:
		 *   name = phony target name
		 *   targets = list of targets to alias
		 */
		void addPhonyTarget(in string name, in string[] targets)
			in(!name.any!isWhite &&
				name.length > 0 &&
				targets.all!"a.length > 0")
		{
			this.targets ~= format!"build %s: phony %-(%s%| $\n    %)\n"(name, targets);
		}

		/**
		 * Add a list of phony targets to the ninja file
		 *
		 * Params:
		 *   phonyTargets = key-value phony targets array
		 */
		void addPhonyTargets(in string[][string] phonyTargets)
		{
			phonyTargets
				.byPair()
				.each!(p => addPhonyTarget(p.key,p.value));
		}

		/**
		 * Add a rule to the ninja file
		 *
		 * Params:
		 *   name = rule name
		 *   variables = variables associated to the rule
		 */
		void addRule(in string name, in string[string] variables)
			in(!name.any!isWhite &&
				"command" in variables)
		{
			rules ~= format!"rule %s\n%s"(
				name,
				generateVariablesList(variables)
			);
		}

		/**
		 * Add a variable to the ninja file
		 *
		 * Params:
		 *   var = key-value encoded tuple representing a ninja variable
		 */
		void addVariable(in Tuple!(string, "key", string, "value") var)
		{
			vars ~= generateVariable(var);
		}

		/// ditto
		void addVariable(in string key, in string value)
		{
			vars ~= generateVariable(key, value);
		}

		/**
		 * Add a list of variables to the ninja file
		 *
		 * Params:
		 *   variables = associative array of ninja variables
		 */
		void addVariables(in string[string] variables)
		{
			vars ~= variables
				.byPair()
				.map!(p => generateVariable(p.key,p.value));
		}

		/**
		 * Generates a list of variables to attach to a ninja rule or target
		 *
		 * Params:
		 *   variables = key-value based variables to generate
		 * Returns: generated ninja style list of variables
		 */
		string generateVariablesList(in string[string] variables) inout
		{
			return format!"%-(  %s%|%)"(
				variables
					.byPair()
					.map!(v => generateVariable(v))
					.array
			);
		}

		/**
		 * Generates a ninja styled variable
		 *
		 * Params:
		 *   var = variable tuple with key-value fields
		 * Returns: returns a generated ninja style variable
		 */
		string generateVariable(in Tuple!(string, "key", string, "value") var) inout
			in(!var.key.any!isWhite)
		{
			return format!"%s = %s\n"(var.key,var.value);
		}

		/// ditto
		string generateVariable(in string key, in string value) inout
		{
			return generateVariable(tuple!("key", "value")(key, value));
		}

		/**
		 * Generates the ninja file with the added rules, vars and targets
		 *
		 * Returns: ninja file text
		 */
		string generate()
		{
			auto ninjaFile = appender!string();

			// minimal required version for this ninja file
			ninjaFile ~= "ninja_required_version = 1.7.1\n";

			ninjaFile ~= vars[];
			ninjaFile ~= rules[];
			ninjaFile ~= targets[];

			if(default_)
				ninjaFile ~= format!"default %s\n"(default_);

			return ninjaFile[];
		}

		/**
		 * Sets a ninja default target
		 *
		 * Params:
		 *   target = name of the target to be the default
		 */
		void setDefault(string target)
		{
			this.default_ = target;
		}

	private:
		Appender!string vars;
		Appender!string rules;
		Appender!string targets;
		string default_ = null;
	}

	this(Project project)
	{
		super(project);

		immutable projectRoot = project.rootPackage.path;

		// check if it's running under ninja
		this.runByNinja = environment.get("DUB_NINJA_GENERATOR") !is null;
		this.internalRegenerate = environment.get("DUB_NINJA_REGENERATE") !is null;

		this.builddir = projectRoot.toNativeString().buildPath(".dub/ninja");

		NativePath ninjaBuildPath =
			(runByNinja ? builddir ~ dirSeparator : projectRoot.toNativeString()) ~ "build.ninja";
		this.ninjaBuildPath = ninjaBuildPath.toNativeString();

		this.file = File(this.ninjaBuildPath, "w");
	}

	override void generateTargets(GeneratorSettings settings, in TargetInfo[string] targets)
	{
		auto fileWriter = file.lockingTextWriter();

		// print initial ninja file header if it's a normal ninja.build file
		if(!runByNinja)
		{
			// add header
			fileWriter.formattedWrite(HEADER_CONTENT,
				m_project.rootPackage.name, /* 1: Project name */
				settings.buildType,         /* 2: Build type */
				settings.compiler.name,     /* 3: Used compiler name */
				settings.config,            /* 4: Used configuration */
			);

			ninjaBuilder.addRule(
				"CLEAN", [
					"command": "/usr/bin/ninja $FILE_ARG -t clean $TARGETS",
					"description": "Cleaning all built files..."
				]);
			ninjaBuilder.addBuildTarget(
				"CLEAN", "clean",
				["PHONY"], ["pool": "console"]);

			ninjaBuilder.addRule(
				"HELP", [
					"command": "/usr/bin/ninja -t targets",
					"description": "All primary targets available:"
				]);
			ninjaBuilder.addBuildTarget(
				"HELP", "help",
				["PHONY"], ["pool": "console"]);

			ninjaBuilder.addRule(
				"CUSTOM_COMMAND", [
					"command": "$COMMAND",
					"description": "$DESC",
					"restat": "1"
				]);

			// phony target to force build everytime
			ninjaBuilder.addPhonyTarget("PHONY", []);
		}

		auto ruleDCompilerFlags = settings.compiler.name == "gdc"
				? "-fdeps=$out.deps"
				: "-makedeps=$out.deps";

		ninjaBuilder.addRule(
			"D_COMPILER", [
				"command": format!`$dc -c %1$s $dflags $target_dflags $DFLAGS -of=$out $in`(ruleDCompilerFlags),
				"description": "Compiling D object $out",
				"deps": "gcc",
				"depfile": "$out.deps"
			]);

		ninjaBuilder.addRule(
			"D_LINK", [
				"command": `$dc -of=$out @$out.rsp $lflags $target_lflags $LFLAGS`,
				"description": "Linking target $out",
				"rspfile": "$out.rsp",
				"rspfile_content": "$in",
			]);

		ninjaBuilder.addRule(
			"AR", [
				"command": `rm -f $out && ar crs $out $in`,
				"description": "Archiving target $out",
			]);

		// setup buildir and rootdir variables
		string rootdirStr;
		{
			auto rootdir = m_project.rootPackage.path;
			rootdir.endsWithSlash = false;
			rootdirStr = rootdir.toNativeString();
		}

		// rule to regenerate build.ninja file
		ninjaBuilder.addRule(
			"REGENERATE_BUILD", [
				"command": format!"%-(%s %|%)%s %(%s%| %)"(
					runByNinja ? ["DUB_NINJA_GENERATOR=1", "DUB_NINJA_REGENERATE=1"] : null,
					thisExePath(),
					Runtime.args[1..$].dup ~ format!"--root=%s"(escapeShellCommand(rootdirStr))
				),
				"description": "Regenerating build files.",
				"generator": "1"
			]
		);
		ninjaBuilder.addBuildTarget(
			"REGENERATE_BUILD", "reconfigure",
			["PHONY"],
			["pool": "console"]);

		ninjaBuilder.addVariables([
			"builddir": format!"%s/%s/%s"(builddir, settings.buildType, m_project.rootPackage.name),
			"rootdir": rootdirStr,
			"ninjapath": this.ninjaBuildPath
		]);

		// setup dc, dflags and lflags variables according to the build type
		string compilerWrapper = settings.platform.compilerBinary
			.replace("ldc", "ldmd");

		// to enable colors on ninja
		string[] dflags = [
			settings.platform.compiler == "gdc"
				? "-fdiagnostics-color=always"
				: "-color=on"
		];
		string[] lflags;

		switch(settings.buildType)
		{
			case "unittest-cov":
				dflags ~= ["-cov"]; goto case;
			case "unittest":
				dflags ~= ["-unittest"]; break;
			case "cov":
				dflags ~= ["-cov"]; break;
			case "debug":
				dflags ~= ["-wi", "-g", "-debug"]; break;
			case "release":
				dflags ~= ["-release", "-O"]; break;
			case "release-debug":
				dflags ~= ["-g"]; goto case "release";
			case "release-nobounds":
				dflags ~= ["-boundscheck=off"]; goto case "release";
			case "profile":
				dflags ~= ["-profile"]; break;
			case "profile-gc":
				dflags ~= ["-profile=gc"]; break;
			default: break;
		}

		// additional flags to the compiler
		dflags ~= chain(
			settings.buildSettings.versions.map!(v => format!"-version=%s"(v)),
			settings.buildSettings.debugVersions.map!(d => format!"-debug=%s"(d)),
			settings.buildSettings.importPaths.map!(i => format!"-I%s"(i)),
			settings.buildSettings.dflags
		).array;
		// additional flags to the linker
		lflags ~= chain(
			settings.buildSettings.libs.map!(l => "-L=-l"~l),
			settings.buildSettings.lflags
		).array;

		ninjaBuilder.addVariables([
			"dc": compilerWrapper,
			"dflags": format!"%-(%s %)"(dflags),
			"lflags": format!"%-(%s %)"(lflags)
		]);

		string defaultTargetPath;

		bool[string] visited;
		auto dubFiles = appender!(string[]);
		foreach(name, info; targets)
		{
			if(visited.get(name, false))
				continue;

			visited[name] = true;
			auto tname = name.replace(":", "_");
			dubFiles ~= info.pack.recipePath.toNativeString();

			string[] target_lflags;
			switch(info.buildSettings.targetType) with(TargetType)
			{
				case staticLibrary:
					target_lflags ~= "-lib";
					break;
				case dynamicLibrary:
					target_lflags ~= "-shared";
					break;
				default: break;
			}

			// add target specific dflags and lflags
			ninjaBuilder.addVariables([
				format!"target_%s_dflags"(tname): format!"%-(%s %)"(
					chain(
						info.buildSettings.versions.map!(v => format!"-version=%s"(v)),
						info.buildSettings.debugVersions.map!(d => format!"-debug=%s"(d)),
						info.buildSettings.importPaths.map!(i => format!"-I%s"(i)),
						info.buildSettings.dflags
					)
				),
				format!"target_%s_lflags"(tname): format!"%-(%s %)"(
					chain(
						info.buildSettings.libs
							.map!(l => "-L=-l"~l),
						target_lflags,
						info.buildSettings.lflags
					)
				)
			]);

			auto oFiles = appender!(string[]);
			foreach(sFile; info.buildSettings.sourceFiles)
			{
				auto relativePath = NativePath(sFile)
					.relativeTo(m_project.rootPackage.path)
					.toNativeString();

				auto inFile = format!"$rootdir/%s"(
					relativePath
				);

				string outFile = () {
					char[] _ = format!"$builddir/%s/%s"(
						tname,
						relativePath
					).dup;
					_[$ - 1] = 'o';
					return _.idup;
				}();
				oFiles ~= outFile;

				ninjaBuilder.addBuildTarget(
					"D_COMPILER", outFile, [inFile],
					["target_dflags": format!"$target_%s_dflags"(tname)]);
			}

			auto targetFileFullPath = info.buildSettings.targetPath
				.buildPath(info.buildSettings.targetName);

			targetFileFullPath = buildTargetName(settings, info, targetFileFullPath);

			auto targetFile = NativePath(
				targetFileFullPath
			).relativeTo(m_project.rootPackage.path)
				.toNativeString();

			if(m_project.rootPackage.name == name)
				defaultTargetPath = targetFileFullPath;

			ninjaBuilder.addBuildTarget(
				"D_LINK", format!"$rootdir/%s"(targetFile), oFiles[],
				["target_lflags": format!"$target_%s_lflags"(tname)]);

			ninjaBuilder.addPhonyTarget(tname, [format!"$rootdir/%s"(targetFile)]);

			if(!runByNinja)
			{

				ninjaBuilder.addBuildTarget(
					"CUSTOM_COMMAND", format!"test_%s"(tname), [],
					[
						"COMMAND": format!"DUB_NINJA_GENERATOR=1 %s generate ninja --build unittest %s"(
							thisExePath(),
							name
						),
						"DESC": "Run unittests generator",
						"pool": "console"
					]
				);

				ninjaBuilder.addBuildTarget(
					"CUSTOM_COMMAND", format!"coverage_%s"(tname), [],
					[
						"COMMAND": format!"DUB_NINJA_GENERATOR=1 %s generate ninja --build unittest-cov %s"(
							thisExePath(),
							name
						),
						"DESC": "Run unittests with coverage generator",
						"pool": "console"
					]
				);
			}
		}

		if(!runByNinja)
			ninjaBuilder.addPhonyTargets([
				"test": [format!"test_%s"(m_project.rootPackage.name)],
				"coverage": [format!"coverage_%s"(m_project.rootPackage.name)]
			]);

		ninjaBuilder.addBuildTarget(
			"REGENERATE_BUILD", "$ninjapath",
			dubFiles[],
			["pool": "console"]);

		// set default target
		ninjaBuilder.setDefault(m_project.rootPackage.name);

		// generate ninja.build file
		file.write(ninjaBuilder.generate());

		// write to ninja.build file and close the stream
		file.close();

		// this will only run if generate is called by ninja
		if(runByNinja && !internalRegenerate)
		{
			import core.stdc.stdlib : _Exit;

			int exitStatus = wait(spawnProcess(["ninja", "-C", builddir]));
			if(exitStatus) _Exit(exitStatus);

			_Exit(wait(spawnProcess([defaultTargetPath])));
		}
	}

	private string buildTargetName(
		ref const GeneratorSettings settings,
		ref const TargetInfo info,
		scope string targetPath)
	{
		string ret = targetPath.idup;

		switch(info.buildSettings.targetType) with(TargetType)
		{
			case library:
			case staticLibrary:
			case dynamicLibrary:
				ret = dirName(ret) ~ dirSeparator ~ "lib" ~ baseName(ret);
				break;
			default: break;
		}

		switch(settings.buildType)
		{
			case "unittest":
			case "unittest-cov":
			case "cov":
				ret ~= "-test";
				break;
			default: break;
		}

		return ret;
	}

	/// whether is running by ninja CUSTOM_COMMAND rule
	private bool runByNinja;
	/// whether is regenerated by intenal build.ninja
	private bool internalRegenerate;
	/// build directory where ninja will write to
	private string builddir;
	/// representing ninja.build file descriptor
	private File file;
	/// represeting ninja file builder
	private NinjaFileBuilder ninjaBuilder;
	/// ninja build path
	private string ninjaBuildPath;
}
